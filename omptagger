#!/usr/bin/env ruby
#
# omptagger
# http://github.com/omp/omptagger
# Modify and display metadata of audio files.
#
# Copyright 2007-2010 David Vazgenovich Shakaryan <dvshakaryan@gmail.com>
# Distributed under the terms of the GNU General Public License v3.
# See http://www.gnu.org/licenses/gpl.txt for the full license text.
#
# Dependencies:
#   Ruby            http://www.ruby-lang.org/
#   RubyGems        http://rubygems.org/
#   rtaglib         http://rubygems.org/gems/rtaglib
#   ruby-filemagic  http://rubygems.org/gems/ruby-filemagic
#   TagLib          http://developer.kde.org/~wheeler/taglib.html

require 'getoptlong'
require 'rubygems'
require 'TagLib'
require 'filemagic'

class Hash
  def longest_key_length
    self.keys.inject(0) do |longest, key|
      key.length > longest ? key.length : longest
    end
  end
end

class String
  @@colour = true

  def colourise(colour)
    case colour
    when :green
      code = '32'
    when :yellow
      code = '33'
    when :cyan
      code = '36'
    else
      return self
    end

    return "\e[#{code}m#{self}\e[0m"
  end

  def format(type)
    case type
    when :file
      indent = ''
      colour = :yellow
    when :action
      indent = '  '
      colour = :green
    when :tag
      indent = '    '
      colour = :cyan
    when :info
      indent = '    '
      colour = nil
    end

    if @@colour
      return indent + self.colourise(colour)
    else
      return indent + self
    end
  end
end

class Metadata
  def initialize(file)
    puts (file + ':').format(:file)

    @filename = File.expand_path(file)
    @write = false

    @file = open(file)
    @metadata = read
  end

  def view
    puts 'Viewing all tags:'.format(:action)

    if @metadata.empty?
      puts 'No tags set.'.format(:info)
      throw :next
    end

    @metadata.sort.each do |field, value|
      value.each do |value|
        output(field, value, @metadata.longest_key_length - field.length)
      end
    end
  end

  def viewtag(field)
    puts ('Viewing ' + field + ' tag:').format(:action)

    unless @metadata.has_key? field
      puts 'Tag not set.'.format(:info)
      throw :next
    end

    @metadata[field].each do |value|
      output(field, value.to_s)
    end
  end

  def addtag(field, value)
    puts ('Adding ' + field + ' tag:').format(:action)

    unless valid_field?(field)
      puts 'Invalid field name.'.format(:info)
      puts 'See Vorbis comment specification.'.format(:info)
      throw :next
    end

    field.upcase!

    if @metadata.has_key?(field)
      @metadata[field] << value
    else
      @metadata[field] = value
    end

    output(field, value)

    @write = true
  end

  def settag(field, value)
    puts ('Setting ' + field + ' tag:').format(:action)

    unless valid_field?(field)
      puts 'Invalid field name.'.format(:info)
      puts 'See Vorbis comment specification.'.format(:info)
      throw :next
    end

    field.upcase!

    @metadata[field] = [value]
    output(field, value)

    @write = true
  end

  def remove
    puts ('Removing all tags:').format(:action)

    if @metadata.empty?
      puts 'No tags set.'.format(:info)
      throw :next
    end

    @metadata.clear
    puts 'Removed.'.format(:info)

    @write = true
  end

  def removetag(field)
    puts ('Removing ' + field + ' tag:').format(:action)

    unless @metadata.has_key? field
      puts 'Tag not set.'.format(:info)
      throw :next
    end

    @metadata.delete(field)
    puts 'Removed.'.format(:info)

    @write = true
  end

  private

  def output(tag, val, padding = 0)
    puts tag.format(:tag) + ' ' * (2 + padding) + val
  end
end

class VorbisComment < Metadata
  def save
    return unless @write

    read.each_key do |field|
      metadata.removeField(TagLib::String.new(field))
    end

    @metadata.each do |field, value|
      field = TagLib::String.new(field)

      value.each do |value|
        metadata.addField(field, TagLib::String.new(value), false)
      end
    end

    @file.save
  end

  def valid_field?(field)
    valid = (32..125).collect do |character|
      character.chr
    end

    field.scan(/./).each do |character|
      return false unless valid.include?(character) 
    end

    return true
  end
end

class FLAC < VorbisComment
  private

  def open(file)
    TagLib::FLAC::File.new(file)
  end

  def metadata
    @file.xiphComment
  end

  def read
    metadata.fieldListMap.hash
  end
end

class Vorbis < VorbisComment
  private

  def open(file)
    TagLib::Vorbis::File.new(file)
  end

  def metadata
    @file.tag
  end

  def read
    metadata.fieldListMap.hash
  end
end

class MP3 < Metadata
  private

  def open(file)
    TagLib::MPEG::File.new(file)
  end

  def read
    metadata = @file.ID3v2Tag.frameListMap.hash

    metadata.each do |field, value|
      metadata[field] = value.collect do |frame|
        frame.to_s
      end
    end
  end
end

def help
  puts <<-end
Usage: omptagger [actions/options] [files]

Actions:
  --view        -v  View all tags
  --view-tag    -t  View a tag
  --add-tag     -a  Add a tag
  --set-tag     -s  Set a tag
  --remove      -r  Remove all tags
  --remove-tag  -d  Remove a tag
  --generate    -g  Generate tags based on filename
  --rename      -m  Rename file based on tags
  --scheme      -n  Change file naming scheme

Options:
  --no-colour   -c  Disable colourisation of output
  --pretend     -p  Disable finalisation of changes
  --help        -h  Display help information
  --info        -i  Display additional information
  end

  exit
end

def info
  puts <<-end
Actions:
  * Multiple actions can be chained together.
  * Actions are executed in the order they are specified.
  * Example: omptagger --view --set-tag ALBUM='Foobar' --view

Schemes:
  * The default file naming scheme is Track - Artist - Title.
  * Schemes must be specified prior to actions that use them.
  * Example: omptagger --scheme '%a - %t' --generate
  * %a - Artist    %* - Wildcard
    %b - Album     %% - Per cent sign
    %d - Date
    %n - Track
    %t - Title

Supported Tags:
  * Vorbis comments: Any field name allowed by specification.
  * ID3v2 frames: Artist, album, title, track, year.

Tag Generation:
  * Underscores in filenames are converted to spaces in tags.
  * Backslashes in filenames are converted to forward slashes in tags.
  end

  exit
end

actions = Array.new
options = Array.new
scheme  = '%n - %a - %t'

GetoptLong.new(
  ['--view',       '-v', GetoptLong::NO_ARGUMENT],
  ['--view-tag',   '-t', GetoptLong::REQUIRED_ARGUMENT],
  ['--add-tag',    '-a', GetoptLong::REQUIRED_ARGUMENT],
  ['--set-tag',    '-s', GetoptLong::REQUIRED_ARGUMENT],
  ['--remove',     '-r', GetoptLong::NO_ARGUMENT],
  ['--remove-tag', '-d', GetoptLong::REQUIRED_ARGUMENT],
  ['--generate',   '-g', GetoptLong::NO_ARGUMENT],
  ['--rename',     '-m', GetoptLong::NO_ARGUMENT],
  ['--scheme',     '-n', GetoptLong::REQUIRED_ARGUMENT],
  ['--no-colour',  '-c', GetoptLong::NO_ARGUMENT],
  ['--pretend',    '-p', GetoptLong::NO_ARGUMENT],
  ['--help',       '-h', GetoptLong::NO_ARGUMENT],
  ['--info',       '-i', GetoptLong::NO_ARGUMENT]
).each do |option, argument|
  option = option.delete('-').intern

  case option
  when :scheme
    scheme = argument
  when :nocolour, :pretend, :help, :info
    options << option
  when :viewtag, :removetag
    actions << [option, argument]
  when :addtag, :settag
    actions << [option, argument.split('=', 2)].flatten
  when :generate, :rename
    actions << [option, scheme]
  else
    actions << [option]
  end
end

help if options.include?(:help)
info if options.include?(:info)
help if actions.empty?

if ARGV.empty?
  puts 'No files specified.'
  exit
end

if options.include?(:nocolour)
  class String
    @@colour = false
  end
end

mime = FileMagic.mime
mime.simplified = true

ARGV.each do |file|
  begin
    raise 'File does not exist.' unless File.exist?(file)

    case mime.file(file)
    when 'audio/x-flac'
      track = FLAC.new(file)
    when 'application/ogg'
      track = Vorbis.new(file)
    when 'audio/mpeg'
      track = MP3.new(file)
    else
      raise 'File extension not recognised.'
    end

    actions.each do |action|
      catch :next do
        track.send(*action)
      end
    end

    track.save unless options.include?(:pretend)
  rescue RuntimeError => message
    $stderr.puts $0 + ': ' + file + ': ' + message
  end
end
